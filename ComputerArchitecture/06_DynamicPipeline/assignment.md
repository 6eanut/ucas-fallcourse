# 动态流水线

静态流水线技术：不允许指令的乱序执行，即一个程序前面的指令一定会先执行，后面的指令一定是后执行

乱序执行的流水线：指令准备好了就执行，不用等候前面不相关的指令

保留站：把指令从有序变成乱序的机构。通过保留站机制，如果发现译码后的指令与前面的指令存在RAW、WAW、WAR中的相关，就让该指令在保留站中等待，WAW、WAR可以通过硬件寄存器重命名的方式来解决。

重命名寄存器：软件寄存器重命名和硬件寄存器重命名。前者往往是用在为了降低循环开销会进行循环展开，循环展开后的每一次运算会用到寄存器，这个可以给每次计算分配不同的寄存器；后者会提供RenFa和RenFb等许多寄存器，这些都是处理器内部的硬件寄存器，不是程序员可见的逻辑寄存器，他们可以把某些指令的结果重定向到该寄存器上，以此来解决WAR和WAW的问题。设计思想是，指令产生结果后不立即修改寄存器，而是先存起来等前面的指令都执行结束，保证不会发生例外或者转移取消以后，才能修改寄存器

重排序缓存：ReOrder Buffer，即ROB，和保留站作用相反，用于保证乱序执行的指令进行按序提交。当把一条指令送入保留站的同时需要将该指令插入ROB队列的尾部，执行完的指令将从ROB队列的头部移除。ROB的大小限制了能乱序执行的指令条数，项数越大则表示正在执行的指令数目(in-flight)越多

指令调度技术：在不影响程序正确性的前提下，通过改变指令的执行次序来避免由于指令相关引起流水线阻塞。分为静态调度和动态调度，前者是由程序员或编译器在程序执行之前进行的指令调度；后者是程序执行过程中由硬件自动进行的指令调度

静态调度：1、指令重排序：调整指令的次序；2、循环展开：为了做循环，往往需要修改循环条件，并进行判断至少两条指令，这就是循环开销。循环展开就是在程序中直接罗列多次循环的运算部分以消除和减少循环开销；3、软件寄存器重命名，在循环展开后，每一次运算都会使用寄存器，可以给每次计算分配不同的寄存器

静态调度的批判看待：寄存器重命名可以消除WAW和WAR相关，但需要更多的寄存器；循环展开可以降低循环开销，但会增加代码空间，可能对指令cache的命中率产生影响；静态调度有局限性，比如访存操作是否相关、cache是否命中，针对于特定的流水线结构、不具有普适性

动态调度：前面指令的阻塞不影响后面的指令继续前进，具体做法为把译码分为译码和读操作数两步。在译码阶段，对指令进行译码并检查结构相关；在读操作数阶段，检查指令的操作数是否准备好，准备好就读操作数并送去执行，否则在一个成为保留站或者发射队列的地方等待。通过把需要等待的指令暂存在保留站中，可以腾出指令执行的通路，后面的不相关的指令就可以继续执行。结构特点为把5级静态流水线的译码阶段分成译码和读寄存器阶段，在指令译码后读寄存器时如果和前面未写回的指令存在RAW相关，则在保留站中等待，并通过对指令的目标寄存器进行重命名消除WAW和WAR

Tomasulo算法：通过硬件寄存器重命名消除WAR、WAW相关，而没有被指令相关阻塞的指令可以尽早地送到功能部件去执行

精确例外：在处理例外的时候，发生例外指令之前所有的指令都已经执行完了，例外指令后面的所有指令都还没有执行。（在乱序执行的流水线中，后面的指令可能先于前面的指令执行完毕），实现精确例外处理的方法，就是把后面指令对机器状态的修改延迟到前面指令都已经执行完(哪怕没有相关)。在流水线中添加提交阶段，在执行和写回阶段，把指令结果写到重排序缓存(ReOrder Buffer，ROB)的临时缓冲器中，在提交阶段把ROB中的内容写回到寄存器或者存储器。这实现了指令提交的有序性，即前面的指令都提交之后，后面的才能提交，即乱序执行，有序结束。

GCD：最大公约数(Greatest Common Divisor)
