# 功能部件

## 1 定点补码加法器

全加器

* A B Cin为输入，S Cout为输出
* S = A ^ B ^ Cin
* Cout = (A & B) | ( (A | B) & Cin )

->

串行进位加法器

* 16位串行进位加法器即把16个全加器串联起来，低位的Cout连接高位的Cin
* 计算完低位的Cout之后，才能计算高位的S和Cout

->

先行(并行)进位加法器

* 进位生成因子：G = A & B
* 进位传递因子：P = A | B
* Cout = G | P & Cin
* 依据上式，可以得出Cout-1 Cout-2 Cout-3 Cout-4关于G-0 P-0 G-1 P-1 G-2 P-2 G-3 P-3的关系式；而G和P是关于A和B的关系式，从而Cout是A和B的关系式
* 这样的四位先行进位加法器可以当作一个“块”，G[0..3] P[0..3] Cin-0为输入，S[0..3] Cout-4为输出

->

16位块间串行加法器

* 把4个先行进位加法器串联
* 每个块的输入Cin都是前一个块的输出Cout

->

16位块间并行加法器

* 需要对块进行修改，增加P和G的输出端(即块的进位生成因子和进位传递因子)
* 1个块的四个输入P和G分别为4个块的输出P和G

---

延迟

全加器：Cout 2级，S 3级

串行进位加法器：Cout-16 32级

先行进位加法器：Cout-4 2级

16位块间串行加法器：Cout-15 8级

16位快件并行加法器：Cout-0~15 6级

## 2 定点补码乘法器

移位加乘法算法

* 根据乘数的位值为1还是为0来选择移位加被乘数还是加零，每次加完之后形成部分积，直到产生最终的乘积

->

Booth补码乘法算法

```
[X*Y]补 = [X]补*Y
符号扩展要做
做加法的时候需要把-按位取反加1得到+
```

Wallace tree

* 用于把n个数相加归约成两个数相加
* 利用n个全加器，可以把3个n位的数相加，转换成2个n+1位的数相加
* 利用n个全加器，可以把m个n位的数相加，转换成2*m/3个n+1位数相加
