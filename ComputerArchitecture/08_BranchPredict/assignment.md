# 转移预测

> 在指令流水线中，转移指令的结果决定后面指令的取指。为了避免由于转移指令引起的流水线阻塞，需要在转移指令的取指或译码阶段预测转移指令的方向和目标地址并从预测的目标地址继续取指令执行。

程序的转移行为

* 转移指令是很频繁的
* 转移指令具有较好的局部性，10%的转移指令占所有转移指令执行次数的90%
* 转移指令具有可预测性，与自己的过去历史有关系，也可能与前后的转移指令有关系

---

软件解决控制相关

* 循环展开，分析循环间相关和循环内相关
* 软流水，重组循环体使不同循环体的指令可以并行执行，新循环体的每个操作来自不同的循环体，以分开数据相关的指令
  * 前两次和最后两次循环要在循环体外进行特殊处理，分别称为该软流水循环体的装入和排空代码
* 条件指令，在执行指令的同时判断某条件，若为真，则正常执行，若为假，则不执行

> 感觉软件解决控制相关就条件指令可以算一条，其他的真的不能算

---

硬件转移预测技术

* 静态预测
  * 总是预测转移成功或不成功
* 动态预测
  * 根据转移指令执行的历史进行预测

转移预测机制(预测器)的性能

* 预测精度
* 正确预测的延迟
  * 在取指阶段预测
    * 需要BTB/Tracecache等
  * 在译码阶段预测
    * 浪费1拍取指槽
  * 通常是在取指阶段根据当前指令的PC值进行预测，并在译码阶段根据译码结果进行再次预测以纠正取指阶段的预测结果
* 转移取消的延迟
  * 尽量提前执行转移指令
  * 流水线中增加提交流水级，确保在指令提交时才能修改寄存器或内存
  * 识别流水线中那些指令需要取消
  * 避免对IO指令预测执行，因为其一旦完成难以取消

根据单条转移指令的历史进行基本转移预测

* 转移指令需具有重复性的规律
* 把每条转移指令的历史记录在转移历史表(Branch History Table)，每次转移预测时根据BHT表的内容判断转移方向
* BHT表以PC的低位作为索引，每项1位，记录同一项上次转移是否成功。也被成为PHT(Pattern History Table)转移模式历史表
* 因为是低位索引(为了减小BHT的大小)，会出现别名干扰的问题。不过出错了纠正就好了，这个就不管了
* 如果把PHT表中的项改为两位，效果会更好，状态分别为11、10、01、00，最高位为1则跳转，为0则不跳转
* BTB(Branch Target Buffer)转移目标缓冲器可以解决对间接转移指令的跳转目标进行预测，在取指阶段来区分跳转指令和普通指令
* BTB每一项包含转移指令PC，转移目标地址以及每项两位的PHT。当取指一个PC指令之后，会在BTB中查找，如果找到了就是转移指令，而且还知道了目标地址

结合转移指令相关性进行预测的两级转移预测技术

* 转移历史寄存器(Branch History Register)记录程序中所有转移指令的历史
* BHR是移位寄存器，CPU每处理一个转移指令，BHR左移一位，最低位由是否转移成功来决定，m位的BHR可以记录CPUm次的转移历史
* 每个转移指令都可以单独记录BHR，这些BHR组织在一起被称为BHT表
* TseYu Yeh和Yale Patt提出了两级自适应转移预测组合。
  * BHR

    * per address BHR(PA)
      * 每条转移指令都有一个BHR，用PC索引BHR
    * global address BHR(GA)
      * GHR，所有转移指令共用一个BHR
    * set address BHR(SA)
      * PC的低位索引BHR
  * PHT

    * per-address PHT(p)
      * 用PC和BHR索引PHT
    * global PHT(g)
      * 用BHR索引PHT
    * set PHT(s)
      * 用部分PC和BHR索引PHT
  * GAg(k)

    * GHR+global PHT
    * GHR存储过去k次转移历史，用GHR的k位值索引2的k次方个项的PHT，PHT每项为两位
  * GAs(k)

    * GHR+set PHT
    * PHT共有2的k+n次方个项，n为PC的低n位

分支别名干扰问题

* Agree预测器
* Bi-Mode分支预测器

---

循环体间和循环体内的真相关 反相关和输出相关

* 均和写有关
* 如果后面的读和前面的写是一个对象，则为真相关
* 如果后面的写和前面的写是一个对象，则为输出相关
* 如果后面的写和前面的读是一个对象，则是反相关
