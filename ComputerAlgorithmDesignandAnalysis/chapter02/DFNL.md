# 双连通与网络可靠性

## 基本概念

**网络可靠性：**由网络抽象成的无向联通图中没**割点**，则称该网络可靠

**双连通：**没有**割点**的连通图称为2-联通

> 例子：通信网络可以抽象成一个无向连通图，通信站抽象成顶点，通信线路抽象成边。通信网络可靠性较高，指如果有一个通信站出现问题，其他通信站之间两两仍能进行通信；如果通信站A出现问题，导致存在两个通信站之间无法进行通信，则在抽象模型中称顶点A为**割点**。

## DFNL算法

**功能：**测试一个连通图是否2-联通；若不是，则可以识别出割点及连通分支

**深索数：**采用**深**度优先搜**索**算法访问连通图时，顶点v被访问的**序**数称为v的深索数 记作DFN(v)

**余边：**{连通图的边}-{连通图通过深度优先搜索之后得到的深度优先生成树的边}

**最低深索数：**min{v的深索数，min{v的所有儿子的最低深索数}，x的深索数(边xv是余边)} 记作L(v)

> 注：定义最低深索数是为了找到图G的割点

### 规律

连通图G、深度优先搜索连通图得到的深度优先生成树T

* T的根是G的割点<=>T的根至少有两个儿子节点
* T的叶子节点不可能是G的割点
* T中非叶子、根的节点u不是G的割点<=>u在T中的每个子树中都存在一个节点关联着一条余边e，e的另一个端点是u的祖先

通俗来讲，判断u是割点当且仅当u至少有一个儿子w，w及其子孙都不与u的任何祖先相邻

**u是割点当且仅当存在w是u的某个儿子使得L(w)>=DFN(u)**

### DFNL

初始化DFN数组为0，即都还没有访问过；num用来记录下一个要访问的序数，初始化为1；

```
proc DFNL(u,v)
// u是当前要访问的节点，v是u的父亲节点
DFN(u)=num;L(u)=DFN(u);num++
遍历u的每一个儿子w
	如果DFN(w)<DFN(u)&w!=v，边uw入栈S
	如果DFN(w)==0，说明w还没被访问过
		DFNL(w,u)
		如果L(w)>=DFN(u)，说明u是割点，栈S弹出边，直到边uw，弹出边组成连通分支
		L(u)=min{L(u),L(w)}
	如果DFN(w)!=0，说明w被访问过
		如果w!=v，L(u)={L(u),DFN(w)}
```
